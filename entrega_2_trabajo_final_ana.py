# -*- coding: utf-8 -*-
"""Entrega_2_trabajo_final_Ana.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15iINn8IpTKir5z2DN5PUqJORWCpieeJa

Integrantes: Diego Robles, Stefania Puerta, Eduardo Polanco, Yulianny Alvarez

#**Carga**
"""

#Se importan librer√≠as
import streamlit as st
import pandas as pd
import pydeck as pdk
import numpy as np
import plotly.express as px
import ploty.graph_objects as go
import base64
from plotly.subplots import make_subplots


# Utilizar la p√°gina completa en lugar de una columna central estrecha
st.set_page_config(layout="wide")

# T√≠tulo principal, h1 denota el estilo del t√≠tulo 1
st.markdown("<h1 style='text-align: center; color: #9045A04;'>üá≤üáΩAn√°lisis socioecon√≥mico de la poblaci√≥n de M√©xico üá≤üáΩ </h1>", unsafe_allow_html=True)

# Cargar datos
df0 = pd.read_csv(url1) # base historico
df1 = pd.read_csv(url2) # base actualüá≤üáΩ
df = pd.concat([df0, df1]) # concatenar las bases
df['OCCUR_DATE'] = pd.to_datetime(df['OCCUR_DATE']) # convertir fecha a formato fecha
    df['OCCUR_TIME'] = pd.to_datetime(df['OCCUR_TIME'], format='%H:%M:%S') # convertir hora a formato fecha
    df['YEAR'] = df['OCCUR_DATE'].dt.year # sacar columna con a√±o
    df['HOUR'] = df['OCCUR_TIME'].dt.hour # sacar columna con hora
    df['YEARMONTH'] = df['OCCUR_DATE'].dt.strftime('%y%m') # sacar columna con a√±o/mes
    df.columns = df.columns.map(str.lower) # convertir columnas a min√∫scula
    return df

df = load_data('historico.csv', 'actual.csv')


#----------------------------------------
c1, c2, c3, c4, c5= st.columns((1,1,1,1,1)) # Dividir el ancho en 5 columnas de igual tama√±o









# Leer archivo con extensi√≥n csv
# #se muestran las primeras 5 filas del dataset
df = pd.read_csv('diagnostico-cdmx_2015_bienes_dur.csv')
df.head()

# Se muestran las √∫ltimas 5 filas del dataset 
df.tail()

# Se visualiza la informaci√≥n general del dataset
df.info()

"""#**Depuraci√≥n**"""

#renombramos variables para entendimiento
df.rename(columns={'anio':'a√±o','nomgeo':'demarcacion', 'mun':'id_demarcacion'}, inplace= True)

#cambiamos tipos de datos, ya que no usamos decimal para mostrar un a√±o o un id
df['a√±o'].astype('int')
df['id_demarcacion'].astype('int')

# En la informaci√≥n general se visualiza que no hay datos nulos pero se verifica
df.isnull().sum()

#verificamos que no haya datos duplicados
df.duplicated()

"""#**An√°lisis de Variables**"""

# Se analiza la descripci√≥n para las variables num√©ricas
df.describe()

#an√°lisis de sexo
sexo = df.groupby(["sexo"])[["total"]].count().reset_index()

# crear gr√°fica
fig = px.bar(sexo, x="sexo", y = "total", title ='<b>Personas seg√∫n su sexo<b>')

fig.update_layout(
    xaxis_title = 'Sexo',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""En el gr√°fico de barras podemos observar como la poblaci√≥n de mujeres es ligeramente m√°s alta que la de los hombres, sin embargo la diferencia no es significativa."""

#an√°lisis de a√±o
df.groupby(["a√±o"])[["total"]].count()

"""Vemos que todos los datos solo son del a√±o 2015, lo cual ya se sabia desde que se escogi√≥ la base de datos."""

#An√°lisis por estratos
estratos = df.groupby(["estratos"])[["total"]].count().reset_index()
# crear gr√°fica
fig = px.bar(estratos, x="estratos", y = "total", title ='<b>Estratos<b>')

fig.update_layout(
    xaxis_title = 'Estrato',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""En el gr√°fico podemos observar como todas las barras son de tama√±o similar,esto nos indica que no hay una variaci√≥n significativa entre los estratos y que hay una situaci√≥n de equilibrio o una distribuci√≥n uniforme de los datos. """

#Analisis por edad
edad = df.groupby(["edad"])[["total"]].count().reset_index()
# crear gr√°fica
fig = px.bar(edad, x="edad", y = "total", title ='<b>Edades<b>')

fig.update_layout(
    xaxis_title = 'Rango de edades',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""E el r√°fico de barras vemos como todos los rango de edades tienen exactamente la misma cantidad, la cual es 160 personas, a esepci√≥n de la categoria no especificado que cuenta con 92 personas."""

#an√°lisis por zonas
demarcacion = df.groupby(["demarcacion"])[["total"]].count().reset_index()
# crear gr√°fica
fig = px.bar(demarcacion, x="demarcacion", y = "total", title ='<b>Demarcaci√≥n territorial<b>')

fig.update_layout(
    xaxis_title = 'Zonas',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Al igual que en los demas gr√°ficos de barras, la variable de demaracci√≥n tambi√©n presenta los mismos valores para las diferentes zonas, siendo la zona de Iztapalapa, la zona de mayor n√∫mero de encuentados con 60 personas, y la de Venustiano Carranza la de menor n√∫mero con 50 personas."""

# se hace an√°lisis de los valores unicos y se muestran en las siguientes 5 lineas
id_demarcacion_unicos = df.id_demarcacion.unique()
estratos_unicos = df.estratos.unique()
sexo_unicos = df.sexo.unique()
edad_unicos = df.edad.unique()
demarcacion_unicos = df.demarcacion.unique()

id_demarcacion_unicos

estratos_unicos

sexo_unicos

edad_unicos

demarcacion_unicos

"""#**Preguntas**"""

#PREGUNTA: ¬øQu√© regiones presentan el mayor estrato social clasificado como ‚ÄúPobreza alta‚Äù
#hacemos analisis de de pobreza por demarcacion, conclu√≠mos que en los que m√°s pobreza se ve son en iztapalapa y la magdalena contreras
df_pobreza_alta = df[df['estratos'] == 'Pobreza alta']
conteo_estratos = df_pobreza_alta.groupby('demarcacion').size().reset_index(name='conteo')

# Ordenar los valores de forma ascendente
conteo_estratos = conteo_estratos.sort_values(by='conteo', ascending=True)

fig = px.bar(conteo_estratos, x='demarcacion', y='conteo', color='demarcacion')
fig.update_layout(title='Conteo de "Pobreza alta" por Demarcaci√≥n')
fig.show()

#PREGUNTA: ¬øcuales son los espacios territoriales que cuentan con el menor numero de personas en estrato social alto?
#hacemos un conteo de estrato alto por demarcacion y encontramos que tienden a tener la misma cantidad, las demarcaciones ventusiano carranza y tl√°huac tienen menos cantidad de personas con alto estrato
df_estrato_alto = df[df['estratos'] == 'Estrato alto']
conteo_estratos = df_estrato_alto.groupby('demarcacion').size().reset_index(name='conteo')

# Ordenar los valores de forma ascendente
conteo_estratos = conteo_estratos.sort_values(by='conteo', ascending=True)

fig = px.bar(conteo_estratos, x='demarcacion', y='conteo', color='demarcacion')
fig.update_layout(title='Conteo de "Estrato alto" por Demarcaci√≥n')
fig.show()

#PREGUNTA: ¬øSegun la informaci√≥n recolectada, cual de los generos esta mas presente en el estrato social "Pobreza Alta"
#al graficar por sexo las personas de pobreza alta nos encontramos que hay bastantes igualdad en cantidad de recursos
df_pobreza_alta = df[df['estratos'] == 'Pobreza alta']

conteo_estratos_sexo = df_pobreza_alta.groupby('sexo').size().reset_index(name='conteo')

fig = px.pie(conteo_estratos_sexo, values='conteo', names='sexo')
fig.update_traces(textposition='inside', textinfo='percent+label')
fig.update_layout(title='Conteo de "Pobreza alta" por Sexo')
fig.show()

#PREGUNTA: ¬øSegun la informaci√≥n recolectada, cual de los generos esta mas presente en el estrato social "Estrato Alto"
# igualmente se nota bastante que no hay varianza si hacemos el filtro por estrato alto
df_estrato_alto = df[df['estratos'] == 'Estrato alto']

conteo_estratos_sexo = df_estrato_alto.groupby('sexo').size().reset_index(name='conteo')

fig = px.pie(conteo_estratos_sexo, values='conteo', names='sexo')
fig.update_traces(textposition='inside', textinfo='percent+label')
fig.update_layout(title='Conteo de "estrato alto" por Sexo')
fig.show()

#¬øCual es la media de bienes durables para cada estrato?
# en este grafico top, podemos ver la media del total de bienes durables con la que cuenta cada estrato siendo el que lidera el Estrato alto, esto claro puede verse sustentado por una mayor facilidad para la adquisici√≥n de estos bienes
conteo_estratos_total = df.groupby('estratos')['total'].agg(count='count', mean='mean').reset_index().sort_values('mean',ascending= False)
fig = px.funnel(conteo_estratos_total, x='mean', y='estratos', color='count')
fig.update_layout(title='Gr√°fico Funnel de Estratos', xaxis_title='Conteo', yaxis_title='Estrato')
fig.show()

#¬øQue genero cuenta con la mayor acumulaci√≥n de bienes durables?
# en la cantidad del total de bienes durables, podemos ver que se dispersa minimamente hacia el sexo de las mujeres la cantidad
conteo_sexo_total = df.groupby('sexo')['total'].agg(count='count', mean='mean').reset_index().sort_values('mean',ascending= False)
fig = px.funnel(conteo_sexo_total, x='mean', y='sexo', color='count')
fig.update_layout(title='Gr√°fico Funnel de Estratos', xaxis_title='Conteo', yaxis_title='sexo')
fig.show()

#Cual es la variaci√≥n de la pobreza alta segun la demarcaci√≥n y la zona?
# el data set no cuenta con una gran varianza en la cantidad de encuestados por demarcaci√≥n y zona por lo tanto se evidencia una falta de aleatoriedad en la recolecci√≥n de los datos
df_pobreza_alta = df[df['edad'] == '60 y mas']
conteo_estratos = df_pobreza_alta.groupby('estratos').size().reset_index(name='conteo')
fig = px.bar(conteo_estratos, x='estratos', y='conteo', color='estratos')
fig.update_layout(title='Conteo de "Pobreza alta" por Demarcaci√≥n')
fig.show()

#Segunda base de datos-Necesidades basicas insatisfechas
df = pd.read_csv('gnbi2020 (1).csv')
df.head()

import matplotlib.pyplot as plt
# Calcular la frecuencia de cada valor en la columna 'tam_hog'
frequency = df['tam_hog'].value_counts()

# Ordenar los valores en orden descendente
sorted_frequency = frequency.sort_values(ascending=False)

# Calcular el porcentaje acumulado
cumulative_percentage = sorted_frequency.cumsum()/sorted_frequency.sum()*100

# Crear un gr√°fico de barras para la frecuencia ordenada
fig, ax = plt.subplots()
ax.bar(range(len(sorted_frequency)), sorted_frequency.values)
ax.set_xticks(range(len(sorted_frequency)))
ax.set_xticklabels(sorted_frequency.index)

# Crear un gr√°fico de l√≠neas para el porcentaje acumulado
ax2 = ax.twinx()
ax2.plot(range(len(cumulative_percentage)), cumulative_percentage.values, color='red', marker='D')

# Establecer la etiqueta del eje y para el gr√°fico de l√≠neas
ax2.set_ylabel('Porcentaje acumulado')

# Establecer la etiqueta del eje x
ax.set_xlabel('tam_hog')

# Establecer el t√≠tulo
ax.set_title('Gr√°fico de Pareto')

plt.show()

"""Analizando el grafico de pareto obtenido al aplicarlo a la variable tama√±o de hogar, observamos que los hogares con 4,3,5,2 y 6 habitantes, correspondiente a el 20% de los hogares con tama√±os forman el 80% de los datos obtenidos, lo que sugiere que debemos centrarnos en analizar los hogares conformados por esos numeros de habitantes."""

#¬øcual es el grupo poblacional por edad que genera el mayor ingreso promedio para su hogar?

#S/Se evidencia que en el grupo poblacional de 18 a 30 a√±os hay un notorio aumento en el valor de ingreso generado para el hogar, se podria hacer la suposici√≥n que al tratarse de un rango poblacional
#tan joven, la razon de que se encuentren en la cima es por su misma juventud que es un caracter de interes para las empresas de hoy en d√≠a. 

# Agrupa los datos por grupos de edad y calcula el ingreso promedio del hogar
age_groups = pd.cut(df['edad'], bins=[0, 18, 30, 40, 50, 60, 100])
avg_income_by_age = df.groupby(age_groups)['ingtrhog'].mean()

# Crea el gr√°fico de l√≠nea
avg_income_by_age.plot(kind='line', marker='o')
plt.xlabel('Grupo de Edad')
plt.ylabel('Ingreso Promedio del Hogar')
plt.title('Tendencia del Ingreso Promedio del Hogar por Grupo de Edad')
plt.xticks(rotation=45)
plt.show()

import seaborn as sns

cross_table = pd.crosstab(df['sexo'], df['situa_conyugal'])
df['sexo'] = df['sexo'].replace({1: 'Masculino', 3: 'Femenino'})
df['situa_conyugal']= df['situa_conyugal'].replace({1.0:'Union libre', 2.0:'separad@',3.0:'Divorciad@',4.0:'Viud@',5.0:'Casad@ civil',6.0:'Casad@ iglesia',7.0:'Casad@ ambas',8.0:'Solter@',9.0:'No especificado'})
cross_table.plot(kind='bar', stacked=True)
plt.xlabel('Sexo')
plt.ylabel('Cantidad')
plt.title('Personas por Sexo y Situaci√≥n Conyugal')
plt.legend(title='Situaci√≥n Conyugal',loc='upper center')
plt.show()